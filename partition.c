#include <errno.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#ifdef BENCHMARK
#include <time.h>
#endif

// SPRAWOZDANIE NOTE:
// Prbowwałem używać 1d array zamiast 2d, ale to było 50% wolniejsze
// Może tak być ponieważ kompilator na tyle optymalizuje kod, że przechodzenie
// przez 2 pointery nie jest takie wolne, a znajdywanie elementu przez mnożenie
// i dodawanie jest wolniejsze

// y - numery kolejnych podzbiorów sum/2 + 1
// x - kolejne liczby naturalne

static bool SAVE_FLAG = false;
static char* SAVE_FILENAME = "matrix.txt";

// given matrix of bools, prints using 0 and 1
void print_matrix(bool** matrix, int y_len, int x_len) {
    for (int y = 0; y < y_len; y++) {
        for (int x = 0; x < x_len; x++) {
            printf("%d ", matrix[y][x]);
        }
        printf("\n");
    }
}

bool** init_matrix(int y_len, int x_len) {
    bool** matrix = (bool**)(malloc(y_len * sizeof(bool*)));
    for (int y = 0; y < y_len; y++) {
        matrix[y] = (bool*)(malloc(x_len * sizeof(bool)));
        for (int x = 0; x < x_len; x++) {
            matrix[y][x] = false;
        }
    }
    return matrix;
}

void free_matrix(bool** matrix, int y_len) {
    for (int i = 0; i < y_len; i++) {
        free(matrix[i]);
    }
    free(matrix);
}

// saves the matrix to a file
void save_matrix(bool** matrix, int y_len, int x_len, char* filename) {
    FILE* file = fopen(filename, "w");
    if (file == NULL) {
        printf("Error opening file: %d \n", errno);
        return;
    }

    for (int y = 0; y < y_len; y++) {
        for (int x = 0; x < x_len; x++) {
            fprintf(file, "%d ", matrix[y][x]);
        }
        fprintf(file, "\n");
    }

    fclose(file);
    printf("Saved matrix to %s \n", filename);
}

// TODO compare against 1d array
// return values:
//  1 - the set can be partitioned
//  0 - the set cannot be partitioned
// -1 - the set cannot be partitioned (sum is odd)
int partition(int* arr, int arr_len, int* set, int* set1_len) {
    // get the sum of all numbers in the array
    int sum = 0;
    for (int i = 0; i < arr_len; i++) {
        sum += arr[i];
    }

    // if the sum is odd, then it's not possible to partition the set
    if (sum % 2 != 0) {
        return -1;
    }

    // y - (sum/2) + 1 (to account for 0)
    // x - next natural numbers
    int y_len = (sum / 2) + 1;
    // +1 to account for 0
    int x_len = arr_len + 1;

    // init matrix
    // first row is filled with 1
    // rest is 0
    bool** matrix = init_matrix(y_len, x_len);

    // fill first row with 1
    for (int i = 0; i < x_len; i++) {
        matrix[0][i] = true;
    }

    for (int y = 1; y < y_len; y++) {
        for (int x = 1; x < x_len; x++) {
            // cell is initalised with a value to its left -
            // if the one on the left is true (a subset of this set can generate
            // the sum) then this cell is true as well (it is the same subset +
            // some other element )
            matrix[y][x] = matrix[y][x - 1];

            int new_element = arr[x - 1];
            // arr[x - 1] is the new element that is going to be added to the
            // subset only consider checking, if the new element is smaller than
            // the sum we are looking for if it were to be bigger, it would not
            // be possible to reach the sum (it would always be too big) only a
            // smaller element, that can be added to some other small elements,
            // can reach the sum and if it's equal, then it's the sum itself
            if (!matrix[y][x] && new_element <= y) {
                // set the current cell to the value of the cell at the previous
                // column and row which contains the subsets which can sum to
                // the current sum - new_element (this means that the current
                // subset can be generated by a previous subset plus the new
                // element)
                matrix[y][x] = matrix[y - new_element][x - 1];
            }
        }
    }

#ifndef BENCHMARK
    print_matrix(matrix, y_len, x_len);

    if (SAVE_FLAG) {
        save_matrix(matrix, y_len, x_len, SAVE_FILENAME);
    }
#endif

    int is_partitionable = matrix[y_len - 1][x_len - 1];

    // use on array to store both sets
    // set1 goes from beggining to end
    // set2 goes from end to beggining
    *set1_len = 0;
    int set2_len = 0;

    if (is_partitionable && set != NULL && set1_len != NULL) {
        // Start from last element in dp table.
        int x = arr_len;
        int y = sum / 2;

        while (x > 0 && y >= 0) {
            // If current element does not
            // contribute to k, then it belongs
            // to set 2.
            x--;
            if (matrix[y][x]) {
                // set2 is filled from the end
                set[(arr_len - 1) - set2_len++] = arr[x];
            }

            // If current element contribute
            // to k then it belongs to set 1.
            else {
                y -= arr[x];
                set[(*set1_len)++] = arr[x];
            }
        }
    }

    free_matrix(matrix, y_len);

    return is_partitionable;
}

int main(int argc, char* argv[]) {
#ifdef BENCHMARK

    // get number of elements from the first argument
    int elements = atoi(argv[1]);

    if (elements % 4 != 0) {
        // stderror
        fprintf(stderr,
                "Error: ammount of elements has to be a multiple of 4, "
                "otherwise the sum is odd\n");
        return 1;
    }

    int arr[elements];

    for (int i = 0; i < elements; i++) {
        arr[i] = i;
    }

    int arr_len = sizeof(arr) / sizeof(arr[0]);

    clock_t start = clock();
    int result = partition(arr, arr_len);

    // print the time it took to run the algorithm in microseconds
    clock_t end = clock();
    double time_spent = (double)(end - start) / CLOCKS_PER_SEC * 1000000;
    printf("%f\n", time_spent);
#else
    // check if the user provided any arguments
    if (argc < 2) {
        printf("Usage: %s [--save FILENAME] n1 n2 n3 ...\n", argv[0]);
        return 1;
    }

    char* filename = "";
    if (strcmp(argv[1], "--save") == 0) {
        // check if the user provided enough arguments
        if (argc < 4) {
            printf("Usage: %s [--save FILENAME] n1 n2 n3 ...\n", argv[0]);
            return 1;
        }
        SAVE_FLAG = true;
        SAVE_FILENAME = argv[2];
        argv += 2;
        argc -= 2;
    }

    // convert the arguments to integers and store them in an array
    // using VLAs (variable length arrays)
    int arr[argc - 1];
    char* endptr;
    for (int i = 1; i < argc; i++) {
        errno = 0;  // reset errno before calling strtol
        long val = strtol(argv[i], &endptr, 10);  // base 10
        if (errno != 0 || *endptr != '\0') {
            printf("Error: argument %d is not an integer (errno=%d)\n", i,
                   errno);
            return errno;
        }
        arr[i - 1] = (int)val;
    }

    // print the arguments
    // for (int i = 0; i < argc - 1; i++) {
    //     printf("%d ", n[i]);
    // }
    // printf("\n");

    // call the partition function and print the result
    int arr_len = sizeof(arr) / sizeof(arr[0]);

    // create a an array which will hold the two sets
    int set[arr_len];
    // the length of the first set, used to figure out where the first
    // set ends and the second set begins
    int set1_len = 0;

    int result = partition(arr, arr_len, set, &set1_len);

    printf("\n");
    if (result == 1) {
        printf("The set can be partitioned\n");

        printf("Set 1: {");
        for (int i = 0; i < set1_len - 1; i++) {
            printf("%d, ", set[i]);
        }
        printf("%d}\n", set[set1_len - 1]);

        printf("Set 2: {");
        for (int i = set1_len; i < arr_len - 1; i++) {
            printf("%d, ", set[i]);
        }
        printf("%d}\n", set[arr_len - 1]);
    } else if (result == 0) {
        printf("The set cannot be partitioned\n");
    } else if (result == -1) {
        printf("The set cannot be partitioned (sum is odd)\n");
    }
#endif

    return 0;
}